<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Impressão de Cartões - HIPERDIA (corrigido)</title>

  <!-- html2pdf (gera PDF a partir de um elemento DOM) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.2/html2pdf.bundle.min.js"
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <style>
    :root{
      --bg: #f6f8fb;
      --primary: #2b6cb0;
      --accent: #4fd1c5;
      --text: #0f1724;
      --btn-radius: 12px;
      --btn-padding: 18px 28px;
      --shadow: 0 6px 18px rgba(16,24,40,0.08);
    }

    html,body{height:100%; margin:0; font-family: "Segoe UI", Roboto, Arial, sans-serif; color:var(--text);}
    body{background:var(--bg); display:flex; align-items:center; justify-content:center; padding:24px;}

    .app {
      width: 920px;
      max-width: calc(100% - 48px);
      background: #fff;
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 28px;
      box-sizing: border-box;
    }

    h1{margin:0 0 8px 0; font-size:20px;}
    p.lead{margin:0 0 20px 0; color: #334155;}

    .controls {
      display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap;
      margin-bottom: 20px;
    }

    .btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      padding: var(--btn-padding);
      font-size:16px;
      border-radius: var(--btn-radius);
      border: none;
      cursor:pointer;
      box-shadow: 0 6px 12px rgba(15,23,42,0.06);
      transition: transform .12s ease, box-shadow .12s ease;
      user-select: none;
    }
    .btn:active{ transform: translateY(1px); }

    .btn-primary {
      background: linear-gradient(180deg,var(--primary), #1e4f8a);
      color: #fff;
    }
    .btn-primary:hover{ transform: translateY(-3px); box-shadow: 0 10px 22px rgba(16,24,40,0.12); }

    .btn-secondary {
      background: linear-gradient(180deg,#fff,#f8fafc);
      color: var(--primary);
      border: 1px solid #e2e8f0;
    }
    .btn-secondary:hover{ transform: translateY(-3px); box-shadow: 0 8px 18px rgba(16,24,40,0.06); }

    .print-options {
      margin-top: 8px;
      display:flex;
      gap:12px;
      align-items:center;
    }

    .preview {
      margin-top: 18px;
      border-top: 1px dashed #e6eef8;
      padding-top: 18px;
      color:#334155;
      font-size:14px;
    }

    .status {
      margin-left: 12px;
      font-size: 14px;
      color:#475569;
    }

    .note { font-size:12px; color:#64748b; margin-top:10px; }

    .ico { width:18px; height:18px; display:inline-block; vertical-align:middle; }

    @media (max-width:720px){
      .controls{flex-direction:column; align-items:stretch;}
      .btn{width:100%;}
    }
  </style>
</head>
<body>
  <main class="app" role="main">
    <h1>Impressão de Cartões — HIPERDIA</h1>
    <p class="lead">Use os botões abaixo para gerar PDF ou imprimir as faces dos cartões. O arquivo <code>model.html</code> deve estar na mesma pasta.</p>


      <div style="display:flex;flex-direction:column;">
        <button class="btn btn-secondary" id="btn-print-card" title="Imprimir cartão (mostra opções frente/verso)">
          <svg class="ico" viewBox="0 0 24 24" fill="none"><path d="M6 9V3h12v6" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><rect x="3" y="9" width="18" height="11" rx="2" stroke="currentColor" stroke-width="1.6"/></svg>
          Imprimir cartão
        </button>

        <div class="print-options" id="print-options" style="display:none;">
          <button class="btn btn-primary" id="btn-print-front" title="Imprime apenas a frente (página 1)">
            Imprimir Frente
          </button>
          <button class="btn btn-primary" id="btn-print-back" title="Imprime apenas o verso (página 2)">
            Imprimir Verso
          </button>
        </div>
      </div>

      <div class="status" id="status">Pronto</div>
    </div>

    <div class="preview" id="preview">
      <strong>Observações:</strong>
      <ul>
        <li>O botão <em>Gerar PDF</em> baixa um arquivo PDF com todas as páginas do <code>model.html</code>.</li>
        <li>Ao usar <em>Imprimir Frente/Verso</em>, o navegador abrirá a janela de impressão. Se não houver impressora, você pode cancelar e usar <em>Gerar PDF</em>.</li>
      </ul>
      <div class="note">Dica: configure escala 100% / sem redimensionamento na janela de impressão para o melhor encaixe.</div>
    </div>
  </main>

  <script>
    // helpers
    const $ = id => document.getElementById(id);
    const setStatus = txt => { const s = $('status'); if (s) s.textContent = txt; console.log('[STATUS]', txt); };

    // fetch model.html and parse as DOM
    async function fetchModelDoc() {
      const resp = await fetch('model.html', { cache: 'no-store' });
      if (!resp.ok) throw new Error('Não foi possível carregar model.html (status ' + resp.status + ')');
      const text = await resp.text();
      const parser = new DOMParser();
      return parser.parseFromString(text, 'text/html');
    }

    // extract only <style> contents from model.html (ignore scripts/links)
    function extractCombinedStyles(doc) {
      try {
        const styleEls = doc.querySelectorAll('style');
        let css = '';
        styleEls.forEach(s => { css += '\n/* from model.html */\n' + s.innerHTML; });
        return css;
      } catch (e) {
        console.warn('Erro ao extrair styles:', e);
        return '';
      }
    }

    // wait for images inside a root element to load (or timeout)
    function waitForImages(root, timeout = 6000) {
      const imgs = Array.from(root.querySelectorAll('img'));
      if (!imgs.length) return Promise.resolve();
      return Promise.all(imgs.map(img => new Promise(resolve => {
        // already loaded successfully
        if (img.complete && img.naturalWidth !== 0) return resolve();
        // already complete but errored
        if (img.complete) return resolve();
        const onDone = () => { cleanup(); resolve(); };
        const onErr  = () => { cleanup(); console.warn('imagem falhou:', img.src); resolve(); };
        const cleanup = () => {
          img.removeEventListener('load', onDone);
          img.removeEventListener('error', onErr);
        };
        img.addEventListener('load', onDone);
        img.addEventListener('error', onErr);
        // safety timeout
        setTimeout(() => { cleanup(); resolve(); }, timeout);
      })));
    }

    // -----------------------
    // generatePdfAll: gera PDF com todas as páginas do model.html
    // -----------------------
    async function generatePdfAll() {
      setStatus('Gerando PDF...');
      try {
        const doc = await fetchModelDoc();
        const css = extractCombinedStyles(doc);

        // container renderizável (opacity:0 ao invés de off-screen)
        const container = document.createElement('div');
        container.style.position = 'fixed';
        container.style.left = '0';
        container.style.top = '0';
        container.style.width = '210mm'; // A4 width
        container.style.boxSizing = 'border-box';
        container.style.opacity = '0';   // invisível, mas renderizável
        container.style.pointerEvents = 'none';
        container.style.zIndex = '9999';
        // ensure visible for html2canvas rendering (some engines fail if display:none or off-screen)

        // inject css extracted
        if (css) {
          const s = document.createElement('style');
          s.type = 'text/css';
          s.appendChild(document.createTextNode(css));
          container.appendChild(s);
        }

        // clone body from model and append
        const bodyClone = doc.body.cloneNode(true);
        container.appendChild(bodyClone);
        document.body.appendChild(container);

        // wait fonts + images
        if (document.fonts && document.fonts.ready) {
          await document.fonts.ready.catch(()=>{ /* non-critical */ });
        }
        await waitForImages(container, 7000);

        // options for html2pdf
        const opt = {
          margin:       [10, 10, 10, 10], // mm
          filename:     'cartoes_hiperdia.pdf',
          image:        { type: 'jpeg', quality: 0.98 },
          html2canvas:  { scale: 2, useCORS: true, logging: false },
          jsPDF:        { unit: 'mm', format: 'a4', orientation: 'portrait' }
        };

        await html2pdf().set(opt).from(container).save();

        document.body.removeChild(container);
        setStatus('PDF gerado e baixado (verifique a pasta de Downloads).');
      } catch (err) {
        console.error(err);
        setStatus('Erro ao gerar PDF: ' + (err.message || err));
        alert('Erro ao gerar PDF. Veja o console para detalhes.');
      }
    }

    // -----------------------
    // printSinglePage: imprime apenas .pagina[index] do model.html
    // -----------------------
    async function printSinglePage(pageIndex) {
      setStatus('Preparando impressão...');
      try {
        const doc = await fetchModelDoc();
        const pages = doc.querySelectorAll('.pagina');
        if (!pages || pages.length === 0) throw new Error('Nenhuma .pagina encontrada em model.html');
        const page = pages[pageIndex];
        if (!page) throw new Error('Página solicitada não existe no model.html');

        const css = extractCombinedStyles(doc);

        // build printable HTML (head contains only extracted CSS)
        const printHTML = `
          <!doctype html>
          <html>
            <head>
              <meta charset="utf-8" />
              <title>Impressão - página ${pageIndex+1}</title>
              <style>
                html,body{margin:0;padding:0;background:#fff;color:#000;}
                ${css}
              </style>
            </head>
            <body>
              ${page.outerHTML}
            </body>
          </html>
        `;

        const printWin = window.open('', '_blank');
        if (!printWin) {
          setStatus('Janela de impressão bloqueada. Gerando PDF como fallback...');
          await fallbackDownloadSingle(page, pageIndex, css);
          return;
        }

        printWin.document.open();
        printWin.document.write(printHTML);
        printWin.document.close();

        printWin.focus();
        setTimeout(() => {
          try {
            printWin.print();
            setStatus('Diálogo de impressão aberto. Se não houver impressora, cancele e gere o PDF.');
          } catch (e) {
            console.warn('Erro ao chamar print():', e);
            fallbackDownloadSingle(page, pageIndex, css);
          }
        }, 700);

      } catch (err) {
        console.error(err);
        setStatus('Erro: ' + (err.message || err));
        alert('Erro ao preparar impressão: ' + (err.message || err));
      }
    }

    // -----------------------
    // fallbackDownloadSingle: gera PDF de uma única página (quando popup bloqueado ou print falha)
    // -----------------------
    async function fallbackDownloadSingle(pageElement, pageIndex, css='') {
      setStatus('Gerando PDF (fallback)...');
      try {
        const container = document.createElement('div');
        container.style.position = 'fixed';
        container.style.left = '0';
        container.style.top = '0';
        container.style.width = '210mm';
        container.style.boxSizing = 'border-box';
        container.style.opacity = '0';
        container.style.pointerEvents = 'none';
        container.style.zIndex = '9999';

        if (css) {
          const s = document.createElement('style');
          s.type = 'text/css';
          s.appendChild(document.createTextNode(css));
          container.appendChild(s);
        }

        container.appendChild(pageElement.cloneNode(true));
        document.body.appendChild(container);

        if (document.fonts && document.fonts.ready) {
          await document.fonts.ready.catch(()=>{});
        }
        await waitForImages(container, 7000);

        const opt = {
          margin:       [10,10,10,10],
          filename:     `cartao_pagina${pageIndex+1}.pdf`,
          image:        { type: 'jpeg', quality: 0.98 },
          html2canvas:  { scale: 2, useCORS: true, logging: false },
          jsPDF:        { unit: 'mm', format: 'a4', orientation: 'portrait' }
        };

        await html2pdf().set(opt).from(container).save();
        document.body.removeChild(container);
        setStatus('PDF da página ' + (pageIndex+1) + ' gerado e baixado.');
      } catch (err) {
        console.error(err);
        setStatus('Erro ao gerar PDF de fallback: ' + (err.message || err));
        alert('Erro ao gerar PDF de fallback: ' + (err.message || err));
      }
    }

    // -----------------------
    // UI events
    // -----------------------
    $('btn-generate-pdf').addEventListener('click', async e => { e.preventDefault(); await generatePdfAll(); });

    $('btn-print-card').addEventListener('click', e => {
      e.preventDefault();
      const opts = $('print-options');
      opts.style.display = (opts.style.display === 'flex' ? 'none' : 'flex');
    });

    $('btn-print-front').addEventListener('click', async e => { e.preventDefault(); await printSinglePage(0); });
    $('btn-print-back').addEventListener('click', async e => { e.preventDefault(); await printSinglePage(1); });

    // init
    (function init(){ setStatus('Aguardando ação. model.html deve estar na mesma pasta.'); })();
  </script>
</body>
</html>
